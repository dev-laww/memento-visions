using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

#nullable enable
namespace Game.SourceGenerator
{
    [Generator]
    public class IncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
                    predicate: (s, _) => s is ClassDeclarationSyntax,
                    transform: (ctx, _) => GetClassDeclarationSyntax(ctx))
                .Where(classDecl => classDecl != null) // Filter out null values
                .Collect();

            context.RegisterSourceOutput(classDeclarations, GenerateSource);
        }

        private void GenerateSource(SourceProductionContext context, ImmutableArray<ClassDeclarationSyntax?> symbols)
        {
            foreach (var symbol in symbols)
            {
                if (symbol == null)
                    continue; // Skip null values

                var source = GeneratePartialClass(symbol);
                context.AddSource($"{symbol.Identifier.Text}.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        private static ClassDeclarationSyntax? GetClassDeclarationSyntax(GeneratorSyntaxContext context)
        {
            var classDecl = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);

            // Check if the class inherits from 'Game.Entities.Enemies.Enemy'
            if (symbol != null && symbol.BaseType?.ToDisplayString() == "Game.Entities.Enemies.Enemy")
            {
                return classDecl;
            }

            return null;
        }

        private string GeneratePartialClass(ClassDeclarationSyntax classDecl)
        {
            // Get the namespace of the class (if it exists)
            var ns = GetFullNamespace(classDecl);
            var className = classDecl.Identifier.Text;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");

            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine($"namespace {ns};");
                sb.AppendLine();
            }


            sb.AppendLine("using Godot;");
            sb.AppendLine();
            sb.AppendLine("[Icon(\"res://assets/icons/enemy.svg\")]");
            sb.AppendLine($"public partial class {className};");

            return sb.ToString();
        }

        private static string GetFullNamespace(BaseTypeDeclarationSyntax syntax)
        {
            string nameSpace = string.Empty;
            SyntaxNode? potentialNamespaceParent = syntax.Parent;

            while (potentialNamespaceParent != null &&
                   potentialNamespaceParent is not NamespaceDeclarationSyntax &&
                   potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
            {
                potentialNamespaceParent = potentialNamespaceParent.Parent;
            }

            if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
            {
                nameSpace = namespaceParent.Name.ToString();

                while (namespaceParent.Parent is NamespaceDeclarationSyntax parent)
                {
                    nameSpace = $"{parent.Name}.{nameSpace}";
                    namespaceParent = parent;
                }
            }

            return nameSpace;
        }
    }
}